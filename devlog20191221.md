# SimpleKernel 开发日志 20191221

写代码这个东西不进则退，前几天还写的很顺，今天把 atom 打开后先是有点迷茫不知道干什么，回忆了一会才想起来今天要把内存映射这块继续理解一下。

pmm 好理解，就是把空闲内存的地址保存起来统一分配，提供 malloc，free，目前的分配算法是直接分配，后面是要改进的。

vmm，主要就是确定一下映射关系，实现 map 和 unmap 函数

物理内存和虚拟内存看名字感觉有关系，但实际实现的时候关系不大，pmm 主要是管理内存分配与回收的，而 vmm 则是强调 映射 这一概念。



# SimpleKernel 开发日志 20191223

决定先实现基本的功能，能跑起来再说重构的事情。

- 目前解决方案

    直接用物理内存相关宏进行映射，但是代码看起来晦涩难懂。

    参考：http://wiki.0xffffff.org/posts/hurlex-10.html

- 优化思路

    参考 vmm.h 中的 `page_directory_t`, `page_table_t` 等定义，使代码目的更加明晰

- 基本完成虚拟内存的管理，现在如果尝试访问无效内存，则会出发 page fault

    ```c
    uint32_t * ptr = (uint32_t*)0xA0000000;
    printk_test("0x%08X\n", *ptr);  // page fault
    ```

    

- 修改了 multiboot magic 错误的问题

    magic 传递的不是地址，而是直接传递的，所以不需要加 PAGE_OFFSET


- vmm 部分，有个刷新页表的指令没弄清楚，似乎都可以？优化的时候需要弄清楚

    ```c
    // 通知 CPU 更新页表缓存
    __asm__ volatile ("invlpg (%0)" : : "a" (va));
    // __native_flush_tlb_single(va);
    ```

    



- bug

    ```C
    ptr_t page = pmm_alloc_pages(9000);
    printk_test("0x%08X\n", page);
    
    // ptr_t page1 = pmm_alloc_pages(1);
    // printk_test("0x%08X\n", page1);
    
    ptr_t page2 = pmm_alloc_page();
    printk_test("0x%08X\n", page2);
    ```
    使用 `pmm_alloc_page()` 会出现缺页异常，但是用 `pmm_alloc_pages()` 分配相同的（打印出来的地址相同）物理内存却不会出现问题。正在将 `objdump -D`结果与 bochs 反汇编结果对比寻找问题原因。

    没有发现 bug 在哪里。。不过把两个函数复用的代码取出来后可以正常用了。。很迷

    ![before](/Users/nzh/Desktop/%E6%88%AA%E5%B1%8F2019-12-23%E4%B8%8B%E5%8D%8811.26.58.png)
    
    ![after](https://tva1.sinaimg.cn/large/006tNbRwly1ga735kbujij30mf0k2tbj.jpg)



这里打个 tag 方便以后找 **[BUG]**



# SimpleKernel 开发日志 20191224

