
// This file is a part of Simple-XX/SimpleKernel
// (https://github.com/Simple-XX/SimpleKernel).
// Based on https://github.com/gcc-mirror/gcc
// type_traits for Simple-XX/SimpleKernel.

#include "stdint.h"
#include "stddef.h"

#ifndef _TYPE_TRAITS_
#define _TYPE_TRAITS_

namespace std {

    /**
     * @defgroup metaprogramming Metaprogramming
     * @ingroup utilities
     *
     * Template utilities for compile-time introspection and modification,
     * including type classification traits, type property inspection traits
     * and type transformation traits.
     *
     * @{
     */

    /// integral_constant
    template <typename _Tp, _Tp __v>
    struct integral_constant {
        static constexpr _Tp                value = __v;
        typedef _Tp                         value_type;
        typedef integral_constant<_Tp, __v> type;
        constexpr operator value_type() const noexcept {
            return value;
        }
        constexpr value_type operator()() const noexcept {
            return value;
        }
    };

    template <typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;

    /// The type used as a compile-time boolean with true value.
    typedef integral_constant<bool, true> true_type;

    /// The type used as a compile-time boolean with false value.
    typedef integral_constant<bool, false> false_type;

    template <bool __v>
    using __bool_constant = integral_constant<bool, __v>;

    template <bool __v>
    using bool_constant = integral_constant<bool, __v>;

    // Meta programming helper types.

    template <bool, typename, typename>
    struct conditional;

    template <typename _Type>
    struct __type_identity {
        using type = _Type;
    };

    template <typename _Tp>
    using __type_identity_t = typename __type_identity<_Tp>::type;

    template <typename...>
    struct __or_;

    template <>
    struct __or_<> : public false_type {};

    template <typename _B1>
    struct __or_<_B1> : public _B1 {};

    template <typename _B1, typename _B2>
    struct __or_<_B1, _B2> : public conditional<_B1::value, _B1, _B2>::type {};

    template <typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
        : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type {};

    template <typename...>
    struct __and_;

    template <>
    struct __and_<> : public true_type {};

    template <typename _B1>
    struct __and_<_B1> : public _B1 {};

    template <typename _B1, typename _B2>
    struct __and_<_B1, _B2> : public conditional<_B1::value, _B2, _B1>::type {};

    template <typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
        : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type {
    };

    template <typename _Pp>
    struct __not_ : public __bool_constant<!bool(_Pp::value)> {};

    template <typename... _Bn>
    inline constexpr bool __or_v = __or_<_Bn...>::value;
    template <typename... _Bn>
    inline constexpr bool __and_v = __and_<_Bn...>::value;

    // Forward declarations
    template <typename>
    struct is_reference;
    template <typename>
    struct is_function;
    template <typename>
    struct is_void;
    template <typename>
    struct __is_array_unknown_bounds;

    // Helper functions that return false_type for incomplete classes,
    // incomplete unions and arrays of known bound from those.

    template <typename _Tp, size_t = sizeof(_Tp)>
    constexpr true_type __is_complete_or_unbounded(__type_identity<_Tp>) {
        return {};
    }

    template <typename _TypeIdentity,
              typename _NestedType = typename _TypeIdentity::type>
    constexpr typename __or_<is_reference<_NestedType>,
                             is_function<_NestedType>, is_void<_NestedType>,
                             __is_array_unknown_bounds<_NestedType>>::type
    __is_complete_or_unbounded(_TypeIdentity) {
        return {};
    }

    // For several sfinae-friendly trait implementations we transport both the
    // result information (as the member type) and the failure information (no
    // member type). This is very similar to std::enable_if, but we cannot use
    // them, because we need to derive from them as an implementation detail.

    template <typename _Tp>
    struct __success_type {
        typedef _Tp type;
    };

    struct __failure_type {};

    template <typename>
    struct remove_cv;

    // __remove_cv_t (std::remove_cv_t for C++11).
    template <typename _Tp>
    using __remove_cv_t = typename remove_cv<_Tp>::type;

    template <typename>
    struct is_const;

    // Primary type categories.

    template <typename>
    struct __is_void_helper : public false_type {};

    template <>
    struct __is_void_helper<void> : public true_type {};

    /// is_void
    template <typename _Tp>
    struct is_void : public __is_void_helper<__remove_cv_t<_Tp>>::type {};

    template <typename>
    struct __is_integral_helper : public false_type {};

    template <>
    struct __is_integral_helper<bool> : public true_type {};

    template <>
    struct __is_integral_helper<char> : public true_type {};

    template <>
    struct __is_integral_helper<signed char> : public true_type {};

    template <>
    struct __is_integral_helper<unsigned char> : public true_type {};

    // We want is_integral<wchar_t> to be true (and make_signed/unsigned to
    // work) even when libc doesn't provide working <wchar.h> and related
    // functions, so check __WCHAR_TYPE__ instead of _GLIBCXX_USE_WCHAR_T.
#ifdef __WCHAR_TYPE__
    template <>
    struct __is_integral_helper<wchar_t> : public true_type {};
#endif

#ifdef _GLIBCXX_USE_CHAR8_T
    template <>
    struct __is_integral_helper<char8_t> : public true_type {};
#endif

    template <>
    struct __is_integral_helper<char16_t> : public true_type {};

    template <>
    struct __is_integral_helper<char32_t> : public true_type {};

    template <>
    struct __is_integral_helper<short> : public true_type {};

    template <>
    struct __is_integral_helper<unsigned short> : public true_type {};

    template <>
    struct __is_integral_helper<int> : public true_type {};

    template <>
    struct __is_integral_helper<unsigned int> : public true_type {};

    template <>
    struct __is_integral_helper<long> : public true_type {};

    template <>
    struct __is_integral_helper<unsigned long> : public true_type {};

    template <>
    struct __is_integral_helper<long long> : public true_type {};

    template <>
    struct __is_integral_helper<unsigned long long> : public true_type {};

    /// is_integral
    template <typename _Tp>
    struct is_integral : public __is_integral_helper<__remove_cv_t<_Tp>>::type {
    };

    template <typename>
    struct __is_floating_point_helper : public false_type {};

    template <>
    struct __is_floating_point_helper<float> : public true_type {};

    template <>
    struct __is_floating_point_helper<double> : public true_type {};

    template <>
    struct __is_floating_point_helper<long double> : public true_type {};

#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_FLOAT128)
    template <>
    struct __is_floating_point_helper<__float128> : public true_type {};
#endif

    /// is_floating_point
    template <typename _Tp>
    struct is_floating_point
        : public __is_floating_point_helper<__remove_cv_t<_Tp>>::type {};

    /// is_array
    template <typename>
    struct is_array : public false_type {};

    template <typename _Tp, size_t _Size>
    struct is_array<_Tp[_Size]> : public true_type {};

    template <typename _Tp>
    struct is_array<_Tp[]> : public true_type {};

    template <typename>
    struct __is_pointer_helper : public false_type {};

    template <typename _Tp>
    struct __is_pointer_helper<_Tp *> : public true_type {};

    /// is_pointer
    template <typename _Tp>
    struct is_pointer : public __is_pointer_helper<__remove_cv_t<_Tp>>::type {};

    /// is_lvalue_reference
    template <typename>
    struct is_lvalue_reference : public false_type {};

    template <typename _Tp>
    struct is_lvalue_reference<_Tp &> : public true_type {};

    /// is_rvalue_reference
    template <typename>
    struct is_rvalue_reference : public false_type {};

    template <typename _Tp>
    struct is_rvalue_reference<_Tp &&> : public true_type {};

    template <typename>
    struct __is_member_object_pointer_helper : public false_type {};

    template <typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
        : public __not_<is_function<_Tp>>::type {};

    /// is_member_object_pointer
    template <typename _Tp>
    struct is_member_object_pointer
        : public __is_member_object_pointer_helper<__remove_cv_t<_Tp>>::type {};

    template <typename>
    struct __is_member_function_pointer_helper : public false_type {};

    template <typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
        : public is_function<_Tp>::type {};

    /// is_member_function_pointer
    template <typename _Tp>
    struct is_member_function_pointer
        : public __is_member_function_pointer_helper<__remove_cv_t<_Tp>>::type {
    };

    /// is_enum
    template <typename _Tp>
    struct is_enum : public integral_constant<bool, __is_enum(_Tp)> {};

    /// is_union
    template <typename _Tp>
    struct is_union : public integral_constant<bool, __is_union(_Tp)> {};

    /// is_class
    template <typename _Tp>
    struct is_class : public integral_constant<bool, __is_class(_Tp)> {};

    /// is_function
    template <typename _Tp>
    struct is_function : public __bool_constant<!is_const<const _Tp>::value> {};

    template <typename _Tp>
    struct is_function<_Tp &> : public false_type {};

    template <typename _Tp>
    struct is_function<_Tp &&> : public false_type {};

}

#endif
