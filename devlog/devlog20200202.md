# SimpleKernel 开发日志 20200202

- 删除了之前进程相关的代码，重写
- 在之前的提交中更新了代码风格

- 关于任务切换

    首先保存旧任务信息：

    ​	cr3，内核栈，寄存器

    将新任务的相关信息填充进寄存器

    ​	cr3，内核栈，寄存器

    开始执行新任务

    ​	指定 eip

    新任务返回后恢复旧任务的信息到寄存器中

- switch_to

    这个函数一定要用内嵌汇编完成，它实际完成了任务切换的动作

    proc->fork()->switch_to->sub_proc->fork()->proc

    否则的话是无法返回调用它的程序的（指不保存额外变量的情况下）



发现内存分配有 bug，这边先暂停一下，把内存先写完



# SimpleKernel 开发日志 20200203

继续重写内存管理

反汇编 pmm_init 的时候发现使用了 xmm 寄存器，查了一下：

`因此，内核只在有限的场合使用FPU、MMX或XMM指令，比如移动或清除大内存区字段、计算校验和等。`(http://abcdxyzk.github.io/blog/2018/01/08/kernel-fpu-2/)

是因为在操作大块结构体 e820map

- 遇到了一个有趣的 bug

    在 pmm.c 中有这么一行代码

    `e820map->map[e820map->nr_map].length = len;`

    直接执行的话会出 INT_INVALID_OPCODE 中断，百思不得其解，最后反汇编的时候发现使用了 xmm 寄存器，然后逐一把个语句分解后发现。只要有 xmm1 寄存器出现就一定会 INT_INVALID_OPCODE，原因我猜有这么几点可能：

    1. 没有初始化 FPU
    2. 32 位代码不支持
    3. 水平不够想不来了

    解决方案：

    1. 在编译选项里添加 -mno-see 禁止生成 see 指令
    2. 分解代码，直到编译器生成不使用 xmm 的汇编代码

    到底是啥问题看了一圈资料也没搞明白，以后如果遇到回来看一下**[MARK]**

- 写 first fit 算法

    感觉思路不太对，明天继续



# SimpleKernel 开发日志 20200204

继续写 ff，现在的问题是如何分配保存物理内存信息的内存。

直接写成数组的话会导致 bss 段过大，有 3MB+

- 解决方案

    在内核结束后存放相关结构体，首先得把 bootinit.c 里面虚拟内存映射加到 8MB

    第二需要在代码里手动分配空间，firstfit.c 中的 pmm_info 变量做了这件事

目前基本稳定

新的问题：multiboot 返回的 mmap 结构是根据什么得出的？

按我的写法，实际上物理内存的前 8MB 是不能用的，否则会覆盖内核数据，但是它给出的布局图显示从 1MB 开始是可用内存，还不清楚这两者的关系是怎样的



# SimpleKernel 开发日志 20200205

昨天的问题想通了，mmap 的地址是理论上可用的地址，实际上因为内核是从物理地址 1MB 处开始的，所以实际可用内存是 mmap 的可用内存减去内核占用的空间，可用内存开始地址为1MB+内核大小

修复了 ff 内存分配的一个小 bug

基本完成 ff free 函数

基本内存管理大致完成，下一步开始写堆管理