# SimpleKernel 开发日志 20200202

- 删除了之前进程相关的代码，重写
- 在之前的提交中更新了代码风格

- 关于任务切换

    首先保存旧任务信息：

    ​	cr3，内核栈，寄存器

    将新任务的相关信息填充进寄存器

    ​	cr3，内核栈，寄存器

    开始执行新任务

    ​	指定 eip

    新任务返回后恢复旧任务的信息到寄存器中

- switch_to

    这个函数一定要用内嵌汇编完成，它实际完成了任务切换的动作

    proc->fork()->switch_to->sub_proc->fork()->proc

    否则的话是无法返回调用它的程序的（指不保存额外变量的情况下）



发现内存分配有 bug，这边先暂停一下，把内存先写完



# SimpleKernel 开发日志 20200203

继续重写内存管理

反汇编 pmm_init 的时候发现使用了 xmm 寄存器，查了一下：

`因此，内核只在有限的场合使用FPU、MMX或XMM指令，比如移动或清除大内存区字段、计算校验和等。`(http://abcdxyzk.github.io/blog/2018/01/08/kernel-fpu-2/)

是因为在操作大块结构体 e820map

- 遇到了一个有趣的 bug

    在 pmm.c 中有这么一行代码

    `e820map->map[e820map->nr_map].length = len;`

    直接执行的话会出 INT_INVALID_OPCODE 中断，百思不得其解，最后反汇编的时候发现使用了 xmm 寄存器，然后逐一把个语句分解后发现。只要有 xmm1 寄存器出现就一定会 INT_INVALID_OPCODE，原因我猜有这么几点可能：

    1. 没有初始化 FPU
    2. 32 位代码不支持
    3. 水平不够想不来了

    解决方案：

    1. 在编译选项里添加 -mno-see 禁止生成 see 指令
    2. 分解代码，直到编译器生成不使用 xmm 的汇编代码

    到底是啥问题看了一圈资料也没搞明白，以后如果遇到回来看一下**[MARK]**

- 写 first fit 算法

    感觉思路不太对，明天继续